## Cache Aside Pattern 重点.

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。

- 更新的时候，**先更新数据库，然后再删除缓存**。

**问题:**

如果a线程去更新数据,事务还没提交,那么b线程来查询数据,发现缓存为空了,那么数据库和redis就不一致了.

再次解决:上面的问题的本质了,我们用旧值更新了缓存.

**那么如何解决呢?**

新建一个队列,这个队列里保存了唯一值,更新的时候,只有队里里有值的时候,才去更新,当事务操作的时候把这个唯一值删掉,

事务操作成功,再把唯一值设置到队列里.

问题又来了,这个队列放哪里呢?redis.



### 先更新数据库，再更新缓存

- （1）线程A更新了数据库
- （2）线程B更新了数据库
- （3）线程B更新了缓存
- （4）线程A更新了缓存

**原因二（业务场景角度）** 有如下两点：

- （1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。
- （2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。

## 四 先删缓存，再更新数据库

该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:

- （1）请求A进行写操作，删除缓存
- （2）请求B查询发现缓存不存在
- （3）请求B去数据库查询得到旧值
- （4）请求B将旧值写入缓存
- （5）请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。