# 羊群效应

当多个客户端请求获取zk创建临时节点来进行加锁的时候，会进行竞争，因为zk独有的一个特性：即watch机制。啥意思呢？就是当A获取锁并加锁的时候，B会监听A的结点变化，当A创建的临时结点被删除的时候，B会去竞争锁.

那么问题来了？如果同时有1000个客户端发起请求并创建临时节点，都会去监听A结点的变化，然后A删除节点的时候会通知其他节点，这样是否会太影响并耗费资源了？那么怎么有效避免羊群效应呢？

# 分布式锁

![image-20210208111020700](/Users/lumac/Library/Application Support/typora-user-images/image-20210208111020700.png)

# 如何解决羊群效应

当多个客户端请求并创建临时节点，此时这些节点名顺序排列，比如A-->znode-01，B--->znode-02，C--->znode-03，此时节点会进行顺序排列，将节点顺序排列，每次只获取当前最小的节点，当我们znode-01获取锁的时候此时znode-02监听其节点， znode-03监听znode-02节点，以此类推…… 每一个后来的节点监听前一个节点，即每次id最小的节点会获取锁，执行完逻辑之后删除临时节点

整体步骤如下：

1. 所有客户端都尝试去创建临时有序节点以获取锁
2. 序号最小的临时有序节点获得锁
3. 未获取到锁的客户端给自己的上一个临时有序节点添加监听
4. 获得锁的客户端进行自己的操作，操作完成之后删除自己的临时有序节点
5. 当监听到自己的上一个临时有序节点释放了锁，尝试自己去加锁
6. 操作完成之后释放锁
7. 之后剩下的客户端重复加锁和解锁的操作

因此，本方法可以有效解决zk的羊群效应，使得分布式锁可以有顺序的执行。 最后，附上zk的分布式锁源码