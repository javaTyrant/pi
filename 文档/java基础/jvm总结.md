## JVM内存结构

　根据 JVM 规范，JVM 内存共分为虚拟机栈、堆(公有)、方法区(公有)、程序计数器、本地方法栈五个部分。



## 垃圾回收算法

### 1.标记-整理算法

### 2.分代收集算法

### 3.标记-清除算法

1. 标记阶段：从根集合出发，将所有活动对象及其子对象打上标记
2. 清除阶段：遍历堆，将非活动对象（未打上标记）的连接到空闲链表上
3. 碎片化， 会导致无数小分块散落在堆的各处
4. 分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块
5. 与写时复制技术不兼容，因为每次都会在活动对象上打上标记

### 4.复制算法



### 1.Serial收集器（串行收集器）

### 2.ParNew收集器

### 3.Parallel Scavenge收集器

### 4.Serial Old 收集器

### 5.Parallel Old收集器

### 6.CMS收集器

目标:最短回收停顿时间为目标

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。

从名字（包含"Mark Sweep"）上就可以看出，CMS 收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：

1. 初始标记（CMS initial mark）stop
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）stop
4. 并发清除（CMS concurrent sweep）

其中，初始标记、重新标记这两个步骤仍然需要"Stop The World"。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC RootsTracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。

![img](https://upload-images.jianshu.io/upload_images/14923529-6401f1a80d3f1c81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，但是 CMS 还远达不到完美的程度，它有以下 3 个明显的缺点：

**第一、导致吞吐量降低。**CMS 收集器对 CPU 资源非常敏感。其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。

CMS 默认启动的回收线程数是**（CPU数量+3）/4**，也就是当 CPU 在4个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如2个）时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。

**第二、CMS 收集器无法处理浮动垃圾**（Floating Garbage），可能出现"Concurrent Mode Failure"失败而导致另一次 Full GC（新生代和老年代同时回收） 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为“**浮动垃圾**”。

也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。

在 JDK 1.5 的默认设置下，CMS 收集器当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数`-XX:CMSInitiatingOccupancyFraction`的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在 JDK 1.6 中，CMS 收集器的启动阈值已经提升至 92% 。

要是 **CMS 运行期间预留的内存无法满足程序需要，就会出现一次"Concurrent Mode Failure"失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。**所以说参数`-XX:CM SInitiatingOccupancyFraction`设置得太高很容易导致大量"Concurrent Mode Failure"失败，性能反而降低。

**第三、产生空间碎片。** CMS 是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC 。

为了解决这个问题，CMS 收集器提供了一个`-XX:+UseCMSCompactAtFullCollection`开关参数（默认就是开启的），用于在CMS收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数`-XX:CMSFullGCsBeforeCompaction`，这个参数是用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。

### 7.G1收集器

G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，G1 是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。

**并行与并发：** G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。

**分代收集：** 与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。

**空间整合：** 与 CMS 的“标记—清理”算法不同，G1 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC 。

**可预测的停顿：** 这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。

在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region （不需要连续）的集合。

G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1 在后台维护一个优先列表，每次根据允许的收集时间，**优先回收价值最大的 Region**（这也就是Garbage-First名称的来由），保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。

在 G1 收集器中，**Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 Remembered Set 来避免全堆扫描的。**

G1 中每个Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

1. **初始标记**（Initial Marking）
2. **并发标记**（Concurrent Marking）
3. **最终标记**（Final Marking）
4. 筛选回收（Live Data Counting and Evacuation）

G1 的前几个步骤的运作过程和 CMS 有很多相似之处。

初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。

并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。

而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。

最后在筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段。

![image-20210204072931033](/Users/lumac/Library/Application Support/typora-user-images/image-20210204072931033.png)

### 8.

## 堆内存最佳实践



## GC日志

### 什么是浮动垃圾

remark过程标记活着的对象，从GCRoot的可达性判断对象活着，但无法标记“死亡”的对象。
如果在初始标记阶段被标记为活着，并发运行过程中“死亡”，remark过程无法纠正，因此变为浮动垃圾，需等待下次gc的到来。

## **Metaspace中的类需要满足什么条件才能够被当成垃圾被卸载回收？**

1. 该类所有的实例都已经被回收；

   

2. 加载该类的ClassLoader已经被回收；

   

3. 该类对应的java.lang.Class对象没有任何地方被引用。

## FULL GC什么时候被触发

### 1.调用System.gc()方法

显示调用System.gc()方法，可能会触发Full GC。因为System.gc()方法只是建议Java虚拟机尽最大努力去回收所有不可用的对象，不一定立刻执行垃圾回收，如果进行垃圾回收，则会触发Full GC。

### 2.老年代空间不足

需要大量连续存储空间的对象会直接分配到老年代、长期存活的对象晋升到老年代，老年代空间不足以存放这些对象的时候会触发Full GC。

### 3.PermGen或Metaspace空间不足

在JDK8之前的版本中，PermGen(永久代)是HotSpot虚拟机中方法区的一种实现，它用于存放类的信息、常量、静态变量等数据，当系统中要加载的类、反射的类等较多时，永久代出现空间不足，在未配置为采用CMS GC的情况下会触发Full GC。

在JDK8中移除了永久代，改用了Metaspace，它也是方法区的一种实现，不过它与永久代最大的区别是Metaspace并不在虚拟机中，而是使用本地内存。当Metaspace空间不足进行回收时，需同时满足如下三个条件的类才会被卸载：该类所有的实例都已经被回收、加载该类的ClassLoader已经被回收、该类对应的java.lang.Class对象没有任何地方被引用，进而触发Full GC。

### 4.Minor GC晋升到老年代的平均大小大于老年代的剩余空间

在发生Minor GC前，会检查老年代是否有足够的连续空间，如果当前老年代最大可用连续空间小于平均历次晋升到老年代大小，则触发Full GC。

### 5.Cocurrent mode failure

在执行CMS GC的过程中，如果此时有线程将对象放入老年代，并且老年代空间不足，或者在做Minor GC的时候，新生代Survivor空间不足，需要放入老年代，而老年代空间也不足，则触发Full GC。

## FULL GC排查思路

方法区和堆一样，都是**线程共享的内存区域**，被用于存储已被虚拟机加载的**类信息（字段等）、即时编译后的代码（方法字节码）、静态变量和常量等数据。**

# JVM:方法区可以GC吗？

根据Java虚拟机规范的规定，**方法区无法满足内存分配需求时，也会抛出OutOfMemoryError异常**，虽然规范规定虚拟机可以不实现垃圾收集，因为和堆的垃圾回收效率相比，方法区的回收效率实在太低，但是**此部分内存区域也是可以被回收的。**

方法区的垃圾回收主要有两种，分别是对**废弃常量的回收（\**常量池的回收\**）和对无用类的回收（\**类的卸载\**）。**

**当一个常量对象\**不再任何地方被引用\**的时候，则被标记为废弃常量，这个常量可以被回收。**

------

### 方法区中的类需要同时满足以下三个条件才能被标记为无用的类：

1.Java堆中**不存在该类的任何实例对象；**

2.加载该类的***\*类加载器已经被回收\****；

**3.该类对应的\**java.lang.Class对象\**不在任何地方被引用，且\**无法在任何地方通过反射访问该类的方法。\****

当满足上述三个条件的类才可以被回收，但是**并不是一定会被回收，需要参数进行控制**，例如HotSpot虚拟机提供了-Xnoclassgc参数进行控制是否回收。

## GC Roots

常说的GC(Garbage Collector) roots，特指的是垃圾收集器（Garbage Collector）的对象，GC会收集那些不是GC roots且没有被GC roots引用的对象。

在java技术体系里面，固定可作为GC Roots的对象包括以下几种：

1、在虚拟机栈中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

2、在方法区中类静态属性引用的对象，例如java类的引用类型静态变量。

3、在方法区中常量引用的对象，例如字符串常量池里的引用。

4、在本地方法栈中JNI引用的对象。

5、Java虚拟机内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象等，还有类加载器。

6、所有被同步锁持有的对象。

7、反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

除了这些固定的GC Roots集合外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。

# [新一代垃圾回收器ZGC的探索与实践](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)

# JVM 老年代和新生代的比例

**Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。**
 在 Java 中，堆被划分成两个不同的区域：
**新生代 ( Young )、老年代 ( Old )。**
 新生代 ( Young ) 又被划分为三个区域：
**Eden、From Survivor、To Survivor。**
 这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。
 堆大小 = 新生代 + 老年代。
 其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。 （在 JDK1.6中，以下涉及的 JVM 默认值均以该版本为准。）
 默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。
 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )， 即：Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。
 JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
 因此，新生代实际可用的内存空间为 9/10 ( 即 90% )的新生代空间

### 怎么查看老年代的内存空间呢

